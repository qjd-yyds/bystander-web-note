# 提高代码的可靠性

## 函数式编程

:::tip 命令式编程
详细的命令机器如何去处理一件事情以达到你想要的效果
:::
:::tip 函数式
将程序分解成一些可重用更可靠且易于理解的部分，然后将它们组合起来，形成一个更易推理的程序整体
:::
函数式编程式一种编程范式，是一种构建计算机程序结构和元素的风格，它把计算看作是对数学函数的评估，避免了状态的变化和数据的可变

## 纯函数

如果函数的调用参数相同，则永远返回相同的结果。他不依赖程序执行期间函数外部任何状态或者数据的变换，只依赖输入的参数

:::: code-group
::: code-group-item 非纯函数

```js
let discount = 0.8
const calculatePrice = price => price * discount
let price = calculatePrice(200)
```

:::
::: code-group-item 纯函数

```js
const calculatePrice = (price, discount) => price * discount
let price = calculatePrice(200, 0.8)
```

:::
::::

## 函数副作用

- 当调用函数时，除了返回函数值以外，还对主调用函数产生附加的影响
- 例如修改全局变量（函数外的变量）或修改参数
- splice pop 这些原生函数 会修改原数组，被认为产生副作用，是不纯的

:::tip 如何保证函数无副作用

- 函数入口使用参数运算，而不修改他
- 函数内不修改函数外的变量
- 运算结果通过函数返回外部
  :::

```js
let a = 5
let foo = () => (a = a * 10)
foo()
console.log(a) // 50
```

## 可变性和不可变性

- 可变性是指一个变量创建以后可以任意修改
- 不可变性是指一个变量，一旦被创建，就永远无法反正改变，不可变性是**函数式编程的核心概念**

通过深拷贝和浅拷贝来实现不可变性

## compose 函数

- 将需要嵌套执行的函数平铺
- 嵌套执行指的是，一个函数的返回值作为下一个函数的参数
- 实现函数式编程中的**pointfree**，使我们专注于转换而不是数据

```js
function Compose() {
  var fns = Array.prototype.slice.call(arguments)
  return function (x) {
    return fns.reduceRight((res, fn) => {
      return fn(res)
    }, x)
  }
}
```
## Pipe 函数
和compose函数一样，不过是从左往右执行
```js
function Pipe() {
  var fns = Array.prototype.slice.call(arguments)
  return function (x) {
    return fns.reduce((res, fn) => {
      return fn(res)
    }, x)
  }
}
```