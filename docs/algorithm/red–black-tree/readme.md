# 红黑树

## 红黑树的规则

:::tip
红色的节点不能是连续的
:::

1. 节点是**红色**或者**黑色**
2. 根节点是黑色
3. 每一个叶子节点都是**黑色的空节点**(NIL 节点)
4. 每个**红色节点**的子节点都是**黑色**(每个叶子到根的所有路径都不能有连续的红色节点)
5. 从任一节点到每个叶子的所有路径都包含**相同数目的黑色节点**

![红黑树](./red_black_tree_demo.jpg)

## 红黑树的相对平衡

:::tip 为什么可以做到最长路径不超过最短路径的两倍

- 路径不能有两个红色节点
- 最短的路径都是黑色节点
- 最长的路径可能是红色和黑色交替
- 由于所有路径都要相同数目的黑色节点

:::

1. 从**根到叶子**的**最长路径**，不会超过**最短路径**的**两倍**
2. 树基本是平衡的
3. 虽然没有做到绝对平衡，但是在最坏的情况下，依然高效

## 变色

:::tip 提示
插入的节点通常为红色

如果插入的是黑色，那么必然导致一条路径里多一个黑色节点
:::
当插入新节点的时候，树可能不平衡，通过三种方式变换，让树平衡

换色=>左旋转=>右旋转

- 为了符合红黑树的规则，会把红色变成黑色，或者黑色变成红色

## 旋转

### 左旋转

逆时针旋转红黑树的两个节点，父节点自己被右孩子替代，自己变成左孩子
![左旋转](./left.png)

### 右旋转

顺时针旋转红黑树的两个节点，父节点被左孩子替代，自己成为自己的右孩子
![右旋转](./right.png)

## 插入操作

:::tip 提示
规定插入的节点为 N，父节点为 P，祖父节点为 G，叔叔节点为 U
:::

插入大致分五种情况

### 1.N 位于树的根上

1. 新节点 N 位于树的根上，没有父节点
2. 直接将红色变成黑色

### 2.P 黑

1. 父节点 P 是黑色节点
2. 所有情况符合

### 3.P 红，U 红

1. 父节点 P 是红色，叔叔节点 U 也是红色，那么祖父节点 G 一定是黑色
2. 把祖父节点 G 变成红色，父节点 G 和叔叔节点 U 变成黑色
3. 如果祖父节点 G 的父节点是红色，递归变色

### 4.U 黑，P 红，N 左节点

:::tip 提示
先变色后右旋转
:::

1. 父亲节点 P 红色，叔叔节点 U 黑色，插入的节点是左节点
2. 父亲节点 P 变成黑色，叔叔 U 不变，祖父 G 红色
3. 右旋转

### 5.P 红，U 黑，P 黑，N 右节点

:::tip 提示
左旋转变成情况 4
:::

1. 父亲节点 P 红色，叔叔节点 U 黑色，插入的节点是右节点
2. 以 P 为根左旋转
3. 将 P 作为新插入的节点，形成情况 4
4. 进入情况 4 判断

## 案例演示

依次插入 10-9-8-7-6-5-4-3-2-1

:::tip 提示
如果是二叉时，会形成一个不平衡树,使用红黑树代替
:::

1. 插入 10 节点
   > 对应情况 1  
   > 把 10 变成黑色
2. 插入 9 节点
   > 放在 10 的左边，不变化
3. 插入 8 节点
   > 对应情况 4，先变色后右旋转  
   > 父节点变成黑，祖父节点变成红
4. 插入 7 节点
   > P 和 U 是红，G 是黑，符合情况 3  
   > 把 P 和 U 改成黑色，G 变成红色  
   > 红黑树要求根节点为黑色，变化根节点为黑色
5. 插入 6 节点
   > 对应情况 4，连续的两个红色  
   > 颜色变化，P 变成黑色，G 变成红色，以 G 为轴进行右旋转
6. 插入 5 节点
   > 对应情况 3 U 和 P 都是红色  
   > 变色 U 和 P 变成黑色，G 变成红色
7. 插入 4 节点
   > 对应情况 4  
   > 变色 U 变成黑色，G 变成红色  
   > 右旋转
8. 插入 3 节点
   > 对应情况 3  
   > U 和 P 变成黑色，P 变成红色  
   > 这个时候 7 和 5 为连续的红色  
   > 这个时候对应情况 4，7 变色为黑色，9 变色为红色，右旋转
9. 插入 2 节点
   > 对应情况 4  
   > 颜色变化 3 变成黑，4 变成红，右旋转
10. 插入 1 节点
    > 对应情况 3  
    > 2 和 4 变成黑色，3 变成红  
    > 对应情况 3  
    > 5 和 9 变成黑色，7 变成红  
    > 因为根节点不是黑色，把 7 变成黑色

<RedBlackTree/>
